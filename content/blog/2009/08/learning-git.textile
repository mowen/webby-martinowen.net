---
title: Learning Git
summary: My thoughts on the Git distributed version system, and some tips for people interested in giving it a try.
created_at: 2009-08-10 18:47:30.087920 +00:00
blog_post: true
published: false
filter: textile
---
I've spent time with Git on home projects since about January, here are my thoughts.

h3. Why should I use Git?

h4. Github

Github was my primary motivation for getting to know Git. It's an amazing piece of work - a cross between Sourceforge and Twitter. When you compare it to Microsoft's open source project hosting effort CodePlex, you can see just how much they are playing catch-up in this area.

I don't even think the code you push to GitHub even needs to be anything special. "Here's someone who pushed everything they had":http://www.catonmat.net/blog/i-pushed-30-of-my-projects-to-github/ (30 projects). And why not? 

"Here's a fun example":http://github.com/rails/rails/commit/22af62cf486721ee2e45bb720c42ac2f4121faf4 of people taking an interest in a commit.

h4. Local commits

What is not to like about local commits? You can commit while disconnected, and it lowers the barrier to entry for every open source project that uses it. Anyone can develop their own Linux or Ruby on Rails. You even get the whole history of a project when you clone it!

Martin Fowler suggests refactoring a project in order to get to know it, and local commits allow you to commit refactorings of a major project without interfering with the master branch. You may never use those refactorings, but the process will have accelerated your learning.

h4. You can amend your (local) commits

Using the <code>git reset</code> command, you can undo commits, without losing the changes (they go back to being "staged").

If you've done something you really shouldn't have, or just screwed up a commit message, this is very useful.

h4. git add --patch

This is a contender for the best Git command, and I was amazed when I first used it. <code>git add --patch</code> allows you to interactively refine your commits by looking through the diffs in a file and choosing which ones to commit. So if you were working on one change and left work in the evening only to start a new change in the same working copy the next morning, Git allows you to view each diff that you made and add them to a commit individually.

If you're using a front-end to Git, you'll be able to scroll through the diffs of a file, and decide which ones to stage, one at a time.

This feature is very useful if you are working on big files can change in different areas for different reasons e.g. CSS files. If you want to experiment with a particular style but want to keep it separate from other style changes, you can use add --patch to commit those changes separately.

h4. git stash

<code>git stash</code> allows you to stash away changes for later. I don't use this command all that much, as I use temporary branches to save changes I may or may not keep, but I mention it here because it's a feature I'd still like to see in Subversion!

h4. Merging is easier

I often have experimental branches in Subversion, but they never stray far from the trunk, because otherwise merging would be too much of a pain. This is because Subversion branches are snapshots, and once the trunk moves on, the branch is left behind until you start to manually merge all those changes back.

h4. Only one .git directory and .gitignore file

A minor irritation with Subversion and CVS is that each checked out directory contains a ".svn" metadata directory. Git just keeps it's metadata in a .git folder at the top level of the cloned repository. This means you simplly delete the .git folder to remove all traces of "gitness".

Files to be ignored can also be specified in one .gitignore file at the top level, and that file is committed like any other. This is something that requires editing the "svn:ignore" property in Subversion, which seems unnecassary when you could edit a single config file instead.

h3. Tips for learning Git

I'm not ashamed to say that Git took a while to get my head around, the fact that I don't use it day-to-day in work probably didn't help. Some pointers that I think apply to learning Git are:

# Be sure to use the repository visualization tool "gitk" from the off, it makes things eveything much clearer than the command line tools.
# Practice on a non-public remote repository, or at least an unpopular one. Git allows you to undo commits, but you won't want to undo a commit that you have pushed.
# Branch more. I create branches more liberally in Git than I do in Subversion, because they are easier to create and merge. I can just hide a temp change on a branch and try code with or without it.
# You don't need to use the full SHA-1 when refering to commits. In Subversion it's easy to look through a log and find the revision you want by a simple revision number. Git replaces this with a terrifying 40 character SHA-1 ID, which would take you a while to shout across the office. You only actually need to use the first 6 characters of the ID.
# Don't be afraid to open up the ".git" directory and look around (assuming you've pushed it to a remote first!)

The last of those suggestions accelerated my learning more than anything else. The structure of a Git repository is simpler than a Subversion one, and all the command line tools do is modify them.

Scott Chacon's Git Internals PDF at Peepcode helped me a great deal in understanding the file system.

h3. Subversion features don't map directly to Git

* <code>git clone</code> != <code>svn checkout</code>
* <code>git checkout</code> == <code>svn revert</code>
* <code>git master branch</code> != <code>svn trunk branch</code>

h3. Mistakes I made

h4. Treating the _master_ branch like the _trunk_ in Subversion.

I'm sure this is a common mistake, because the master branch is the default, and most users will make the assumption that it is the equivalent of trunk.

h4. Pushing things I shouldn't have

While getting to know Git I deleted a number of repositories on Github because their history contained things that shouldn't have been publicly available. (See my earlier comment about practicing on a non-public remote repo.)

h4. Remotes becoming out of sync with local branches

Sometimes a commit would be duplicated in both the remote and the local branch, because (why because? should I leave this bit out?)
